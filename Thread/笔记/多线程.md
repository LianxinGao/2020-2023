1. 多任务
2. 程序：指令和数据的有序集合，其本身没有任何运行的含义，是一个静态概念。
3. 进程：进程特别大（如播放器、QQ、游戏）它是程序的一次执行过程，是动态概念，**是系统资源分配的单位**。
进程中可以包含若干个线程。
4. 线程：**CPU调度和执行的单位**。  
- - -
Conclusion：
- 线程就是独立的执行路径。
- 程序运行时，若没有自己创建线程，后台也会有多个线程，如main、gc线程。
- 一个进程中，开辟多个线程，线程运行由调度器（CPU）安排调度，不能人为干预。
- 对同一份资源操作，会存在资源抢夺的问题，需要并发。
- 线程会带来额外开销，并发控制开销。
- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。
- - -
#### 1. 创建线程方式
1. 继承Thread类  
重写run方法，在主函数调用start方法开启线程，注意线程开启需要时间。
2. 实现runnable接口  
将实现runnable接口的对象P放到Thread当中去运行（new Thread(P).start()）  
这里的Thread叫做**代理**  
由于Java是单继承，所以推荐使用runnable。
3. callable接口  
创建线程池，submit到线程池，关闭线程
- - - 
1. 静态代理模式
2. lambda表达式：接口只有一个方法的时候可以用。
3. 线程优先级，默认为5。max：10，min：1。
4. 守护线程（daemon）  
    - 线程分用户线程和守护线程
    - 虚拟机必须确保用户线程执行完毕
    - 虚拟机不用等待守护线程执行完毕（如日志记录、垃圾回收等）
- - -
#### 2. 线程同步
1. 每个线程都拥有一把锁
2. 队列 + 锁 才能保证线程安全
3. 线程不安全的集合
    - List：可能写到同一个位置。
4. synchronized：对象对应一把锁，获得锁才能操作该对象，可能影响效率（这个对象里面有读操作时）
    - 可以在方法上加锁：public synchronized void setMethod()

    